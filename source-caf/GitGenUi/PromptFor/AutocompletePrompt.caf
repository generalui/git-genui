import &ArtStandardLib, &PromptForLib, {} &sliceAnsi

readlineUtils = require :inquirer/lib/utils/readline
Base = require :inquirer/lib/prompts/base
Paginator = require :inquirer/lib/utils/paginator
observe = require :inquirer/lib/utils/events
{ takeWhile } = &rxjs/operators

colors =
  tip:      &chalk.grey
  selected: &chalk.white.bold
  warning:  &chalk.yellow
  error:    &chalk.red

applyColors = (customColors) ->
  object c, k in colors
    c = customColors?[k] ? c

    if c is String
      throw new Error "invalid color #{k}: '#{c}'" unless color = &chalk[c]
      color
    else if c is Function
      c
    else throw new Error "invalid color for #{k} - expecting string or function"

class AutocompletePrompt extends Base

  constructor: (options, rl, answers) ->
    @throwParamError :source unless @opt.source is Function
    @currentChoices = []
    @renderCount = 0
    @selected = 0
    @default = @opt.default
    @opt.default = null
    @errorMessage = null
    @colors = applyColors @opt.colors
    @paginator = new Paginator

  logFile: (args...) ->
    [args] = args if args.length = 1
    &fs.appendFileSync
      :prompt.log
      if args is String then args else
        formattedInspect args
      + "\n"

  _run: (@done) ->
    if isArray @rl.history
      @rl.history = []

    @bindEvents()
    @search()
    @

  bindEvents: ->
    events = observe @rl

    events.line.pipe takeWhile dontHaveAnswer = -> !@answer
    .forEach (line) ->
      if @currentChoices.length <= @selected
        @rl.write line
        @search line

      else
        @answer = @currentChoices[@selected]
        @render()
        @screen.done()
        @done @answer

    events.keypress.pipe takeWhile dontHaveAnswer
    .forEach (e) ->
      @errorMessage = null

      switch e.key?.name
      when :down
        @setSelected @selected + 1
        @render()
        readlineUtils.up @rl, 2

      when :up
        @setSelected @selected - 1
        @render()

      else
        @search @rl.line

  listRender: (choices, pointer) ->
    process.stdout extract columns

    array {value}, i in choices
      line = sliceAnsi value, 0, columns - 3

      if isSelected = i == pointer
            @colors.selected "" #{&figures.pointer} #{line}
      else  "  #{line}"

    .join "\n"

  render: ->
    content = @getQuestion()
    bottomContent = ''

    if @renderCount == 0
      content += @colors.tip "" (Use arrow keys or type to search)

    if @errorMessage
      content += @colors.error "" ERROR: #{@errorMessage}

    @renderCount++

    if @answer
      content += @colors.selected @answer.label ? @answer.value

    else
      content += @rl.line

      bottomContent = if @searching
         '  ' + @colors.tip 'Searching...'

      else if @currentChoices.length > 0
        @paginator.paginate
          @listRender @currentChoices, @selected
          @selected
          @opt.pageSize

      else
        '  ' + @colors.warning 'No results...'

    @screen.render content, bottomContent

  search: (searchTerm) ->
    @setSelected 0

    if @searchedOnce
      @searching = true
      @currentChoices = []
      @render()
    else
      firstSearch = true
      @searchedOnce = true

    @lastPromise = thisPromise = @opt.source
      @answers
      @lastSearchTerm = searchTerm

    .then (choices) -> if thisPromise == @lastPromise
      @currentChoices = array choice in choices
        if choice is String then value: choice else choice

      if firstSearch
        @setSelected
          findDefaultItemIndex @currentChoices, @default
          ? 0

      @searching = false
      @render()

    .catch (error) -> @errorMessage = error.message

  setSelected: (selected) -> @selected = (selected ? 0) %% max 1, @currentChoices.length
