import &ArtStandardLib, &ArtClassSystem, &Lib

&inquirer.registerPrompt :autocomplete &inquirer-autocomplete-prompt
&inquirer.registerPrompt :checkbox-plus &inquirer-checkbox-plus-prompt

inquire = (options) ->
  throw new Error "no need to specify 'name' - just your value is returned w/o a wrapping object" if present options.name
  Promise.then -> &inquirer.prompt merge options, name: :value, message: options.prompt ? options.message
  .then ({value}) -> value

# if the terminal window is not wide enough, autocomplete truncates the strings
# FINE FINE - but, it returns the truncated string, not the full string.
# This re-selects the full string
patchAutocompleteResult = (value, strings) ->
  return value if value in strings
  find v in strings when value.length < v.length && value == v.slice 0, value.length
  ? value # just in case

class Core

  # all props in a match b
  partialEq = (a, b)->
    !find v, k in a when b[k] != v

  findDefaultItem = (items, _default) ->
    switch
    when _default is Object then  find item from items when partialEq _default, item
    when _default is String then  find item from items when item.value == _default
    else                          find item from items when item.default
  ##
    IN:
      items:
        array of strings, presented in order
        OR array of objects with at least a 'value' property:
          value: string presentation value
          default: if true, select this one as the default

      multiselect: false

      prompt: string for prompt

      default: string exactly matching default item

    OUT: selected item, as passed in

  @selectList: ({items, multiselect, prompt, default: _default}) ->
    if isString items[0]
      itemsWereStrings = true
      items = array string from items with value: string

    if defaultItem = findDefaultItem items, _default
      items = array item from items into [defaultItem] when item != defaultItem

    strings = array {value} from items with value

    inquire {}
      prompt
      default:    _default
      type:       if multiselect then :checkbox-plus else :autocomplete
      pageSize:   20
      source:     autocompleteFromStrings strings
      highlight:  true
      searchable: true

    .then (value) ->

      value = patchAutocompleteResult value, strings

      item = items[strings.indexOf value]
      if itemsWereStrings
        item.value
      else item

  @yesNo: (options) ->
    inquire merge
      type:     :expand
      default:  if options.default == true || options.default == :yes then :yes else :no
      choices:
        key: :y value: :yes name: "" yes
        key: :n value: :no  name: "" no
      options

  ## input
    IN: options
      canBeBlank: t/f - unless true, if the result is an empty string, then default will be returned
  @input: (options) ->
    inquire merge
      type: :input
      options
    .then (str) ->
      unless options.canBeBlank
        if present str then str else options.default

  @password: (options) =>
    @input merge options, type: :password

  @password: (options) ->
    inquire merge
      type: :password
      options
