import &StandardImport, {} &ignoreRejections

{}
  getCommitMessage: ({type, story, message, coauthors, storyState, breakingChange, body}) ->
    compactFlattenAll
      type ? "(type)"
      ": "
      if story?.id
        "" [##{story.id}]#{if storyState && storyState != story.status then " (#{storyState})"}\_

      message ? "(message)"

      if body
        "" \n\n#{body.replace /\n\n\n+/g, "\n\n"}

      if breakingChange
        "" \n\nBREAKING CHANGE: #{} breakingChange

      if coauthors?.length > 0
        "\n\n\n" +
          array coauthor in coauthors
            "" Coauthored-by: #{coauthor}
          .join "\n"
    .join ''
    .trim()

  getCommitComment: (state) ->
    state extract generatedCommitMessage, storyState, status, commit, remote

    """
      story #{storyState || :progressed} with commit: `#{commit}`, branch: `#{status?.current ? :unknown}`, remote: `#{remote?.refs.fetch ? :none}`, message:
      > #{generatedCommitMessage}
      (auto-comment by git-genui v#{&package.version})

  extractSavableState = (state) -> {message, type, coauthors, story, breakingChange, body, footers} = state

  saveState: (state) ->
    if state
      userConfig.saveCommitOptionsForProject extractSavableState state

    state

  getInitialCommitState: (options = {}) ->
    Promise.deepAll merge
      userConfig.commitOptionsForProject
      {}
        status:     if options.quiet then &Git.status else &Git.printStatus()
        stories:    tracker.configured && ignoreRejections -> tracker.stories
        members:    tracker.configured && ignoreRejections -> tracker.members
        myAccount:  tracker.configured && ignoreRejections -> tracker.myAccount
        project:    tracker.configured && ignoreRejections -> tracker.project
        remote:     &Git.aRemote
        options
    .then (state) ->
      unless projectConfig.conventionalCommit
        objectWithout state, :breakingChange
      else state