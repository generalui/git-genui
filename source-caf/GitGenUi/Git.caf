import &StandardImport, {} &Style
SimpleGit = require(:simple-git/promise)()

class Git extends BaseClass

  @getGitConfig: ->
    Promise.then -> SimpleGit.listConfig()
    .then ({all}) -> all

  @normalizeGitStatus: (status) ->
    return status unless status.files # already normalized
    staged = []
    unstaged = []
    untracked = []

    each file in status.files
      if file.index && file.index != :untracked
        staged.push    merge file, status: file.workingDir || file.index

      if file.workingDir
        if file.workingDir == :untracked then    untracked.push merge file, status: file.workingDir
        else                                     unstaged.push  merge file, status: file.workingDir

    {}
      staged, unstaged, untracked
      status.current, status.tracking
      status.ahead, status.behind

  @commit: (options) =>
    generatedCommitMessage = getCommitMessage options
    Promise.then -> SimpleGit.commit generatedCommitMessage
    .then (result) -> merge result, {} generatedCommitMessage

  @stage: (files...) ->
    Promise.then -> SimpleGit.add compactFlatten files

  @unstage: (files...) ->
    Promise.then -> SimpleGit.reset [] :head, compactFlatten(files)...

  @classGetter
    @email: ->
      SimpleGit.raw []
        :config
        :user.email
      .then (email)-> email.trim()

    @remotes: ->
      Promise.then -> SimpleGit.getRemotes true

    @origin: ->
      @remotes.then (remotes) ->
        find remote in remotes when remote.name == :origin
          remote.refs.fetch

    @aRemote: ->
      @remotes.then (remotes) ->
        first = undefined
        find remote in remotes when first ?= remote; remote.name == :origin
        ? first

    @rawStatus: ->
      Promise.then -> SimpleGit.status()
      .then (o) -> object k in Object.keys o
        status = o[k]
        if k == :files
          status = array file in status
            merge
              objectWithout file, :working_dir
              index:      decodeStatus file.index
              workingDir: decodeStatus file.working_dir
        else status

    @status: =>
      @rawStatus
      .then @normalizeGitStatus

  statusCodes =
    D:  :deleted
    C:  :conflicted
    R:  :renamed
    A:  :added
    M:  :modified
    ?:  :untracked
    ' ': null

  decodeStatus = (statusCode) ->
    statusCodes[statusCode]

  @loadStatus:  (options) ->
    options extract? status, origin, remotes, email
    Promise.deepAll {}
      status  ?= @status
      origin  ?= @origin
      remotes ?= @remotes
      email   ?= @email
    .then (loaded) -> merge options, loaded

  commitParser = new CommitParser

  normalizeListLogLine = ({hash, date, message, refs, author_name, author_email, body}) ->
    if body
      message += "\n#{body}"

    try
      parsed = commitParser.parse message
    catch error
      log.error normalizeListLogLine: {} message, error

    merge
      {}
        date: Date.parse date
        hash, refs
        authorName: author_name
        authorEmail: author_email
        rawMessage: message

      parsed

  @getCommitLog: (options) ->
    SimpleGit.log options
    .then ({all}) -> all.map normalizeListLogLine

  @getStatusReport: (options) ->
    @loadStatus options
    .then ({status, origin, remotes, email, verbose}) ->
      {staged, unstaged, untracked} = status
      outputOne = ({path, status}) -> "  #{pad status + ':', 12} #{path}"

      compactFlattenAll
        if verbose
          formattedInspect verbose: {}
            projectConfig.projectFolder
            userConfig.projectKey
            git: {} remotes, status

        if origin?
          "" Origin:        #{Style.green origin}

        else []
          :Remotes:
          array {refs, name} in remotes
            "" \_ #{pad name + ":", 12} #{Style.green refs.fetch}

        "" Branch:        #{Style.green status.current}
        "" Tracking:      #{Style.green status.tracking}
        "" Author:        #{Style.green email}

        if staged.length > 0 then []
          "" \nChanges to be committed:       #{Style.grey "(#{pluralize :file, staged.length})"}
          array file in staged with
            if file.status == :modified && file.index != :modified
              Style.yellow outputOne file
            else
              Style.green outputOne file
          .sort()
          .join :\n

        if unstaged.length > 0 then []
          "" \nChanges not staged to commit:  #{Style.grey "(#{pluralize :file, unstaged.length})"}
          Style.red
            array file in unstaged with outputOne file
            .sort()
            .join :\n

        if untracked.length > 0 then []
          "" \nUntracked files:               #{Style.grey "(#{pluralize :file, untracked.length})"}
          Style.red
            array file in untracked with outputOne file
            .sort()
            .join :\n

        ''

      .join :\n

  @printStatus: (options)=>
    @getStatusReport options
    .then log
