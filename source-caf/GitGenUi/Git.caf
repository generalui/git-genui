import &StandardImport, {} &colors
SimpleGit = require(:simple-git/promise)()

class Git extends BaseClass

  @getGitCommitMessage: ({type, story, message, coauthors, storyState}) ->
    compactFlattenAll
      type ? "(type)"
      ": "
      if story?.id
        "" [##{story.id}]#{if storyState && storyState != story.status then " (#{storyState})"}\_

      message ? "(message)"

      if coauthors
        "\n\n\n" +
          array coauthor in coauthors
            "" Coauthored-by: #{coauthor}
          .join "\n"
    .join ''

  @getGitConfig: ->
    Promise.then -> SimpleGit.listConfig()
    .then ({all}) -> all

  @normalizeGitStatus: (status) ->
    return status unless status.files # already normalized
    staged = []
    unstaged = []
    untracked = []

    each file in status.files
      if file.index && file.index != :untracked
        staged.push    merge file, status: file.workingDir || file.index

      if file.workingDir
        if file.workingDir == :untracked then    untracked.push merge file, status: file.workingDir
        else                                     unstaged.push  merge file, status: file.workingDir

    {}
      staged, unstaged, untracked
      status.current, status.tracking
      status.ahead, status.behind

  @commit: (options) =>
    generatedCommitMessage = @getGitCommitMessage options
    Promise.then -> SimpleGit.commit generatedCommitMessage
    .then (result) -> merge result, {} generatedCommitMessage

  @stage: (files...) ->
    Promise.then -> SimpleGit.add compactFlatten files

  @unstage: (files...) ->
    Promise.then -> SimpleGit.reset [] :head, compactFlatten(files)...

  @classGetter
    @email: ->
      SimpleGit.raw []
        :config
        :user.email
      .then (email)-> email.trim()

    @remotes: ->
      Promise.then -> SimpleGit.getRemotes true

    @origin: ->
      @remotes.then (remotes) ->
        find remote in remotes when remote.name == :origin
          remote.refs.fetch

    @aRemote: ->
      @remotes.then (remotes) ->
        first = undefined
        find remote in remotes when first ?= remote; remote.name == :origin
        ? first

    @rawStatus: ->
      Promise.then -> SimpleGit.status()
      .then (o) -> object k in Object.keys o
        status = o[k]
        if k == :files
          status = array file in status
            merge
              objectWithout file, :working_dir
              index:      decodeStatus file.index
              workingDir: decodeStatus file.working_dir
        else status

    @status: =>
      @rawStatus
      .then @normalizeGitStatus

  statusCodes =
    D:  :deleted
    C:  :conflicted
    R:  :renamed
    A:  :added
    M:  :modified
    ?:  :untracked
    ' ': null

  decodeStatus = (statusCode) ->
    statusCodes[statusCode]

  @printStatus: (options)->
    unstagedColors =
      deleted:    :red
      conflicted: :magenta
      added:      :yellow
      renamed:    :blue
      modified:   :red
      untracked:    :red
      staged:     :green

    stagedColors =
      deleted:    :brightRed
      conflicted: :brightMagenta
      added:      :brightYellow
      renamed:    :brightBlue
      modified:   :brightCyan
      untracked:  :brightGray
      staged:     :brightGreen

    Promise.all [] @status, @origin, @remotes, @email
    .tap ([status, origin, remotes, email]) ->
      if options?.verbose
        log verbose: {}
          &ProjectConfig.projectFolder
          &UserConfig.userConfig.projectKey
          git: {} remotes, status

      if origin?
        log "" Origin:        #{colors.green origin}
      else
        log :Remotes:
        each {refs, name} in remotes
          log "" \_ #{pad name + ":", 12} #{colors.green refs.fetch}

      log "" Branch:        #{colors.green status.current}
      log "" Tracking:      #{colors.green status.tracking}
      log "" Author:        #{colors.green email}

      outputOne = ({path, status}) -> "  #{pad status + ':', 12} #{path}"

      {staged, unstaged, untracked} = status

      if staged.length > 0
        log "" \nChanges to be committed:       #{colors.grey "(#{pluralize :file, staged.length})"}
        log
          array file in staged with
            if file.status == :modified && file.index != :modified
              colors.yellow outputOne file
            else
              colors.green outputOne file
          .sort()
          .join :\n

      if unstaged.length > 0
        log "" \nChanges not staged to commit:  #{colors.grey "(#{pluralize :file, unstaged.length})"}
        log colors.red
          array file in unstaged with outputOne file
          .sort()
          .join :\n

      if untracked.length > 0
        log "" \nUntracked files:               #{colors.grey "(#{pluralize :file, untracked.length})"}
        log colors.red
          array file in untracked with outputOne file
          .sort()
          .join :\n

      log ''

    .then ([status]) -> status