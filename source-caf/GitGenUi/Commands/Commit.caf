import &StandardImport, &UserConfig, &CommandsLib, &ProjectConfig, &Git

##
  IN: state:
    status:     git status
    stories:    tracker stories
    members:    tracker members
    myAccount:  current user's tracker account

configure = (state) ->
  ConfigureMenu exitPrompt: :back
  .then -> Promise.deepAll {}
    stories:    ignoreRejections -> tracker.stories
    members:    ignoreRejections -> tracker.members
    myAccount:  ignoreRejections -> tracker.myAccount

  .then (updates) -> merge state, updates

statusColors =
  staged:     :green
  unstaged:   :red
  untracked:  :red

description:
  """
    Commit is the main command for git-genui. The primary goal is to generate a well-formatted git-commit message. Commit will prompt for configuration of needed, as well as giving an opportunity to stage or unstage files for the commit. Alternatively, you can stage files for your commit before calling git-genui-commit.

    All commandline options are optional. The are provided to streamling the commit process if needed.

options:
  message:    :message      "" entier your git-commit message on the command-line
  coauthors:  :authors      "" one more more coauthor emails (separated by spaces)
  type:       :type         "" Commit type string. Should be of the form: [major, minor or patch]/short-word
  story-id:   :id           "" Input the tracker story id directly on the command-line. It will be validated against existing stories.

run: (options) ->
  Promise.deepAll merge
    userConfig.commitOptionsForProject
    {}
      status:     &Git.printStatus()
      stories:    ignoreRejections -> tracker.stories
      members:    ignoreRejections -> tracker.members
      myAccount:  ignoreRejections -> tracker.myAccount
      project:    ignoreRejections -> tracker.project
      options

  .then validateStory
  .then validateType

  .tap ({status}) ->
    if status.staged.length + status.unstaged.length + status.untracked.length == 0
      log.warn "" No local changes to commit.
      process.exit 1

  .then fillInMissingState
  .then saveState
  .then (state) ->
    &PromptFor.menu
      state

      preprocessState: (state) ->
        if present state.message
          log "" Commit message preview:
          log "  " +
            &colors.bold &colors.brightGreen getGitCommitMessage state
            .replace /\n/g, "\n  "
          log ''

        state

      items: (state) ->
        state extract myAccount, message, story, members, statusSummary, status, type, coauthors

        compactFlatten []
          action: EditCommitMessage,  value: "" Edit message:           #{} presentValue message
          if myAccount && projectConfig.project
            action: StoryMenu,        value: "" Select story:           #{} presentValue if story?.id then stripAnsi tracker.formatStory story
          else
            action: configure,        value: "" Select story:           #{} colorNotPresent("configure tracker")

          action: SelectCommitType,   value: "" Select type:            #{} presentValue type

          if myAccount
            action: SelectCoauthors,  value: "" Change coauthors:       #{} if members?.length == 0 then colorNotPresent 'only you on project' else presentValue if coauthors?.length > 0 then coauthors
          else
            action: configure,        value: "" Change coauthors:       #{} colorNotPresent("configure tracker")

          action: EditGitStage,       value: "" Edit staged files:      #{}
            compactFlatten array statusCat from :staged :unstaged :untracked when status[statusCat]?.length > 0
              &colors[statusColors[statusCat]] "" #{status[statusCat].length} #{statusCat}
            .join ', '

          if present message then action: CommitNow,          value: "" Commit now

      postprocessState: saveState
