import &StandardImport, &UserConfig, &CommandsLib, &ProjectConfig

##
  IN: state:
    status:     git status
    stories:    tracker stories
    members:    tracker members
    myAccount:  current user's tracker account

ActionMenu = (state) ->
  return unless state
  state extract
    status
    stories
    members
    myAccount

    message
    type
    story
    coauthors

  configure = (state) ->
    ConfigureMenu exitPrompt: :back
    .then -> Promise.deepAll {}
      stories:    ignoreRejections -> tracker.stories
      members:    ignoreRejections -> tracker.members
      myAccount:  ignoreRejections -> tracker.myAccount

    .then (updates) -> merge state, updates

  otherMembers = array member in members when member.id != myAccount.id
  {staged, unstaged, untracked} = status
  statusColors =
    staged: :green
    unstaged: :red
    untracked: :red

  statusSummary =
    compactFlatten array statusCat from :staged :unstaged :untracked when status[statusCat]?.length > 0
      &colors[statusColors[statusCat]] "" #{status[statusCat].length} #{statusCat}
    .join ', '

  &PromptFor.selectList
    prompt:  "" Select action:
    items: compactFlatten []
      action: EditGitStage,       value: "" 1. Edit staged files:      #{} statusSummary
      if myAccount && projectConfig.project
        action: StoryMenu,        value: "" 2. Select story:           #{} presentValue(if story then stripAnsi tracker.formatStory story)
      else
        action: configure,        value: "" 2. Select story:           #{} colorNotPresent("configure tracker")

      action: SelectCommitType,   value: "" 3. Select type:            #{} presentValue type
      action: EditCommitMessage,  value: "" 4. Edit message:           #{} presentValue message

      if myAccount
        action: SelectCoauthors,  value: "" 5. Change coauthors:       #{} if otherMembers.length == 0 then colorNotPresent("only you") else presentValue coauthors
      else
        action: configure,        value: "" 5. Change coauthors:       #{} colorNotPresent("configure tracker")

      # key: :autoPush    value: "" auto-push on/off
      # key: :storyStatus value: "" update story status: started -> finished / (no change: finished)
      action: CommitNow,          value: "" 6. Commit now              #{} &colors.grey getGitCommitMessage state
      # action: configure,          value: "" 9. Configure
      key: :abort                 value: "" 0. exit

  .then ({action}) ->
    if action?
      Promise.then -> action state
      .then saveState
      .then ActionMenu

description: "" main interactive commit interface
options:
  message:    :message      "" entier your git-commit message on the command-line
  coauthors:  :authors      "" one more more coauthor emails (separated by spaces)
  type:       :type         "" Commit type string. Should be of the form: [major, minor or patch]/short-word
  story-id:   :id           "" Input the tracker story id directly on the command-line. It will be validated against existing stories.

run: (options) ->
  Promise.deepAll merge
    userConfig.commitOptionsForProject
    {message, coauthors, type, storyId} = options
    {}
      status:     &Git.printStatus()
      stories:    ignoreRejections -> tracker.stories
      members:    ignoreRejections -> tracker.members
      myAccount:  ignoreRejections -> tracker.myAccount
      options

  .then validateStory
  .then validateType

  .tap ({status}) ->
    if status.staged.length + status.unstaged.length + status.untracked.length == 0
      log.warn "" No local changes to commit.
      process.exit 1
  .then fillInMissingState
  .then saveState
  .then ActionMenu
