import &StandardImport, &UserConfig, &CommitLib

colorizeValue = &colors.yellow
colorNotPresent = &colors.grey

presentValue = (value, noneValue = :none) ->
  if present value
    if (value is Array) and value[0] is String
      array v in value
        colorizeValue v
      .join ', '

    else if value is String
      colorizeValue value

    else
      formattedInspect value, color: true
  else
    colorNotPresent noneValue

noop = (a) -> a

##
  IN: state:
    status:     git status
    stories:    tracker stories
    members:    tracker members
    myAccount:  current user's tracker account

CommitNow = (state) ->
  if state.pretend
    Promise.resolve {}
      branch: state.status.current
      commit: :pretending
      summary: changes: 123 insertions: 456 deletions: 789
  else
    &Git.commit state

  .then ({branch, commit, summary}) ->
    {staged} = state.status
    log success: {}
      committed: staged
      branch
      commit
      summary: object v in summary with v | 0
    null

  .tap -> saveState objectWithout state, :message

ActionMenu = (state) ->
  return unless state
  state extract
    status
    stories
    members
    myAccount

    message
    type
    story
    coauthors

  otherMembers = array member in members when member.id != myAccount.id
  {staged, unstaged, untracked} = status
  statusColors =
    staged: :green
    unstaged: :red
    untracked: :red
  statusSummary =
    compactFlatten array statusCat from :staged :unstaged :untracked when status[statusCat]?.length > 0
      &colors[statusColors[statusCat]] "" #{status[statusCat].length} #{statusCat}
    .join ', '

  &PromptFor.selectList
    prompt:  "" Select action:
    items: compactFlatten []
      action: EditGitStage,       value: "" 1. Edit staged files:      #{} statusSummary
      action: StoryMenu,          value: "" 2. Select story:           #{} if !myAccount then colorNotPresent("configure tracker") else presentValue(if story then stripAnsi tracker.formatStory story)
      action: SelectCommitType,   value: "" 3. Select type:            #{} presentValue type
      action: EditCommitMessage,  value: "" 4. Edit message:           #{} presentValue message
      action: SelectCoauthors,    value: "" 5. Change coauthors:       #{} if !myAccount then colorNotPresent("configure tracker") else if otherMembers.length == 0 then colorNotPresent("only you") else presentValue coauthors

      # key: :autoPush    value: "" auto-push on/off
      # key: :storyStatus value: "" update story status: started -> finished / (no change: finished)
      action: CommitNow,          value: "" 6. Commit now              #{} &colors.grey getGitCommitMessage state
      key: :abort                 value: "" 0. Abort / quit

  .then ({action}) ->
    if action?
      Promise.then -> action state
      .then saveState
      .then ActionMenu

saveState = (state) ->
  userConfig.saveCommitOptionsForProject {message, type, coauthors, story} = state if state
  state

fillInMissingState = (state) ->
  Promise.resolve state
  .then (state) -> if state.status.staged.length == 0 then EditGitStage       state else state
  .then (state) -> unless state.story                 then StoryMenu          state else state
  .then (state) -> unless present state.type          then SelectCommitType   state else state
  .then (state) -> unless present state.message       then EditCommitMessage  state else state

validateStory = (state) ->
  state extract story, stories
  if storyId = story?.id
    unless story = find story in stories when story.id == storyId
      log.warn merge {}
        message: "" Invalid story or storyId
        story
        storyId

    state.story = story

  state

description: "" interactive commit2
run: (options) ->
  Promise.deepAll merge
    userConfig.commitOptionsForProject
    {message, coauthors, type, storyId} = options
    {}
      status: &Git.status.then normalizeGitStatus
      tracker.stories
      tracker.members
      tracker.myAccount
      options

  .then validateStory
  .tap ({status}) ->
    if status.staged.length + status.unstaged.length + status.untracked.length == 0
      log.warn "" No local changes to commit.
      process.exit 1
  .then fillInMissingState
  .then saveState
  .then ActionMenu
